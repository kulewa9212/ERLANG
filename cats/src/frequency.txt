-module(frequency)

-export([start/0, stop/0, allocate/0, deallocate/1]).
-export([init/0]).

start() -> register(frequency, spawn(frequency, init, [])).

init() -> Frequencies = {get_frequencies(), []},
loop(Frequencies).

% Hard Coded

get_frequencies() -> [10,11,12,13,14,15] .

%% the client functions

stop() -> call(stop) .
allocate() -> call(allocate) .
deallocate() -> call(deallocate) .

%% We hide all massage passing and the message
%% protocol ina a functional interface

call(Message) ->
freguency ! {request, self(), Message},
receive 
{reply, Reply} -> Reply
end .


%% Main loo 

loop(Frequencies) -> 
receive
{request, Pid, allocate} -> 
{NewFrequencies, Pid, allocate} = allocate(Frequencies,Pis),
reply(Pid,Reply),
loop(NewFrequencies);
{request, Pid, {deallocate, Freq}} ->
NewFrequencies=deallocate(Frequencies,Freq),
reply(Pid,Reply),
loop(NewFrequencies) ;
{request, Pid, stop} ->
reply(Pid, Reply) 
end .

reply(Pid, Reply) -> 
Pid ! {reply, Reply} .

%% The internal help funtions use dto allocate and 
%% deallocate frequencies

allocate({[], Allocated}, _Pid) ->
 {{[], Allocated}, {error, no_frequency}};
allocate({[Freq|Free], Allocated}, Pid) ->
 {{Free, [{Freq, Pid}|Allocated]}, {ok, Freq}}.

 deallocate({Free, Allocated}, Freq) ->
 NewAllocated=lists:keydelete(Freq, 1, Allocated),
 {[Freq|Free], NewAllocated}.

 



















